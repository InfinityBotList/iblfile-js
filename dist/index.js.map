{
  "version": 3,
  "sources": ["../node_modules/tslib/tslib.es6.js", "../node_modules/@obsidize/tar-browserify/common/constants.js", "../node_modules/@obsidize/tar-browserify/common/tar-utility.js", "../node_modules/@obsidize/tar-browserify/common/async-uint8array.js", "../node_modules/@obsidize/tar-browserify/header/tar-header-link-indicator-type.js", "../node_modules/@obsidize/tar-browserify/header/tar-header-field-type.js", "../node_modules/@obsidize/tar-browserify/header/tar-header-field.js", "../node_modules/@obsidize/tar-browserify/header/tar-header-field-definitions.js", "../node_modules/@obsidize/tar-browserify/header/tar-header-metadata.js", "../node_modules/@obsidize/tar-browserify/entry/tar-entry-attributes.js", "../node_modules/@obsidize/tar-browserify/entry/tar-entry-metadata.js", "../node_modules/@obsidize/tar-browserify/entry/tar-entry.js", "../node_modules/@obsidize/tar-browserify/entry/tar-entry-iterator-base.js", "../node_modules/@obsidize/tar-browserify/entry/async-tar-entry-iterator.js", "../node_modules/@obsidize/tar-browserify/entry/tar-entry-iterator.js", "../node_modules/@obsidize/tar-browserify/core/tarball.js", "../src/lzwGo.ts", "../src/index.ts"],
  "sourcesContent": ["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n", "export var Constants;\r\n(function (Constants) {\r\n    Constants.SECTOR_SIZE = 512;\r\n    Constants.OCTAL_RADIX = 8;\r\n    Constants.USTAR_TAG = 'ustar';\r\n    Constants.USTAR_INDICATOR_VALUE = `${Constants.USTAR_TAG}\\0`;\r\n    Constants.USTAR_VERSION_VALUE = '00';\r\n    Constants.HEADER_SIZE = Constants.SECTOR_SIZE;\r\n    Constants.FILE_MODE_DEFAULT = 511; // '777' octal\r\n})(Constants || (Constants = {}));\r\n", "import { Constants } from './constants';\r\nexport var TarUtility;\r\n(function (TarUtility) {\r\n    function isNumber(value) {\r\n        return typeof value === 'number' && !Number.isNaN(value);\r\n    }\r\n    TarUtility.isNumber = isNumber;\r\n    function isString(value) {\r\n        return typeof value === 'string';\r\n    }\r\n    TarUtility.isString = isString;\r\n    function isPopulatedString(value) {\r\n        return isString(value) && value.length > 0;\r\n    }\r\n    TarUtility.isPopulatedString = isPopulatedString;\r\n    function isUint8Array(value) {\r\n        return !!(value && value instanceof Uint8Array);\r\n    }\r\n    TarUtility.isUint8Array = isUint8Array;\r\n    function sizeofUint8Array(value) {\r\n        return isUint8Array(value) ? value.byteLength : 0;\r\n    }\r\n    TarUtility.sizeofUint8Array = sizeofUint8Array;\r\n    function encodeString(input) {\r\n        return isPopulatedString(input) ? new TextEncoder().encode(input) : new Uint8Array(0);\r\n    }\r\n    TarUtility.encodeString = encodeString;\r\n    function decodeString(input) {\r\n        return isUint8Array(input) ? new TextDecoder().decode(input) : '';\r\n    }\r\n    TarUtility.decodeString = decodeString;\r\n    function generateChecksum(input) {\r\n        return isUint8Array(input) ? input.reduce((a, b) => (a + b), 0) : 0;\r\n    }\r\n    TarUtility.generateChecksum = generateChecksum;\r\n    function clamp(value, min, max) {\r\n        return Math.max(min, Math.min(value, max));\r\n    }\r\n    TarUtility.clamp = clamp;\r\n    function advanceSectorOffset(currentOffset, maxOffset) {\r\n        return Math.min(maxOffset, advanceSectorOffsetUnclamped(currentOffset));\r\n    }\r\n    TarUtility.advanceSectorOffset = advanceSectorOffset;\r\n    function advanceSectorOffsetUnclamped(currentOffset) {\r\n        return (1 + Math.floor(currentOffset / Constants.SECTOR_SIZE)) * Constants.SECTOR_SIZE;\r\n    }\r\n    TarUtility.advanceSectorOffsetUnclamped = advanceSectorOffsetUnclamped;\r\n    function roundUpSectorOffset(currentOffset) {\r\n        return Math.ceil(currentOffset / Constants.SECTOR_SIZE) * Constants.SECTOR_SIZE;\r\n    }\r\n    TarUtility.roundUpSectorOffset = roundUpSectorOffset;\r\n    function getSectorOffsetDelta(currentOffset) {\r\n        return roundUpSectorOffset(currentOffset) - currentOffset;\r\n    }\r\n    TarUtility.getSectorOffsetDelta = getSectorOffsetDelta;\r\n    function parseIntOctal(input) {\r\n        return parseIntSafe(input, Constants.OCTAL_RADIX);\r\n    }\r\n    TarUtility.parseIntOctal = parseIntOctal;\r\n    function decodeTimestamp(value) {\r\n        return Math.floor(parseIntSafe(value)) * 1000;\r\n    }\r\n    TarUtility.decodeTimestamp = decodeTimestamp;\r\n    function encodeTimestamp(value) {\r\n        return Math.floor(parseIntSafe(value) / 1000);\r\n    }\r\n    TarUtility.encodeTimestamp = encodeTimestamp;\r\n    function sanitizeTimestamp(value) {\r\n        return decodeTimestamp(encodeTimestamp(value));\r\n    }\r\n    TarUtility.sanitizeTimestamp = sanitizeTimestamp;\r\n    function deserializeAsciiPaddedField(value) {\r\n        return removeTrailingZeros(decodeString(value));\r\n    }\r\n    TarUtility.deserializeAsciiPaddedField = deserializeAsciiPaddedField;\r\n    function deserializeIntegerOctalTimestamp(value) {\r\n        return decodeTimestamp(deserializeIntegerOctal(value));\r\n    }\r\n    TarUtility.deserializeIntegerOctalTimestamp = deserializeIntegerOctalTimestamp;\r\n    function deserializeIntegerOctal(input) {\r\n        return parseIntSafe(decodeString(input).trim(), Constants.OCTAL_RADIX);\r\n    }\r\n    TarUtility.deserializeIntegerOctal = deserializeIntegerOctal;\r\n    function removeTrailingZeros(str) {\r\n        const pattern = /^([^\\0]*)[\\0]*$/;\r\n        const result = pattern.exec(str);\r\n        return result ? result[1] : str;\r\n    }\r\n    TarUtility.removeTrailingZeros = removeTrailingZeros;\r\n    function serializeIntegerOctalToString(value, maxLength) {\r\n        return parseIntSafe(value)\r\n            .toString(Constants.OCTAL_RADIX)\r\n            .padStart(maxLength, '0');\r\n    }\r\n    TarUtility.serializeIntegerOctalToString = serializeIntegerOctalToString;\r\n    function parseIntSafe(value, radix = 10, defaultValue = 0) {\r\n        if (isNumber(value))\r\n            return Math.floor(value);\r\n        const parsed = parseInt(value, radix);\r\n        return isNumber(parsed) ? parsed : defaultValue;\r\n    }\r\n    TarUtility.parseIntSafe = parseIntSafe;\r\n    function concatUint8Arrays(a, b) {\r\n        if (!isUint8Array(b))\r\n            return a;\r\n        if (!isUint8Array(a))\r\n            return b;\r\n        const aLength = a.byteLength;\r\n        const bLength = b.byteLength;\r\n        const result = new Uint8Array(aLength + bLength);\r\n        if (aLength > 0)\r\n            result.set(a, 0);\r\n        if (bLength > 0)\r\n            result.set(b, aLength);\r\n        return result;\r\n    }\r\n    TarUtility.concatUint8Arrays = concatUint8Arrays;\r\n})(TarUtility || (TarUtility = {}));\r\n", "import { __awaiter } from \"tslib\";\r\nimport { Constants } from './constants';\r\nimport { TarUtility } from './tar-utility';\r\n/**\r\n * Searches the given AsyncUint8Array for a block that meets the given predicate.\r\n * @param offset the absolute offset to start reads from\r\n * @param stepSize the _relative_ step size in multiples of SECTOR_SIZE (i.e. stepSize = 3 --> blockSize = SECTOR_SIZE * 3)\r\n */\r\nexport function findInAsyncUint8Array(target, offset, stepSize, predicate) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!target || !predicate) {\r\n            return null;\r\n        }\r\n        const maxLength = yield target.byteLength();\r\n        offset = TarUtility.clamp(offset, 0, maxLength);\r\n        if (offset >= maxLength) {\r\n            return null;\r\n        }\r\n        // don't allow reading more than ~250KB at a time by default\r\n        const blockSize = TarUtility.clamp(stepSize, 1, Constants.SECTOR_SIZE) * Constants.SECTOR_SIZE;\r\n        let found = false;\r\n        let cursor = offset;\r\n        let result;\r\n        while (!found && cursor < maxLength) {\r\n            result = yield target.read(cursor, blockSize);\r\n            found = predicate(result, cursor, target);\r\n            cursor += blockSize;\r\n        }\r\n        if (found) {\r\n            return { source: target, value: result, offset: cursor };\r\n        }\r\n        return null;\r\n    });\r\n}\r\n", "/**\r\n * Sector type flag values taken from here:\r\n * (see \"Type flag field\" in wiki)\r\n *\r\n * https://en.wikipedia.org/wiki/Tar_(computing)\r\n *\r\n * Special notes from the wiki:\r\n * 'A'\u2013'Z' - Vendor specific extensions (POSIX.1-1988)\r\n * All other values\t- Reserved for future standardization\r\n */\r\nexport var TarHeaderLinkIndicatorType;\r\n(function (TarHeaderLinkIndicatorType) {\r\n    /**\r\n     * Special local indicator for this module to indicate a parse failure\r\n     */\r\n    TarHeaderLinkIndicatorType[\"UNKNOWN\"] = \"UNKNOWN\";\r\n    TarHeaderLinkIndicatorType[\"NORMAL_FILE\"] = \"0\";\r\n    TarHeaderLinkIndicatorType[\"NORMAL_FILE_ALT1\"] = \"\\0\";\r\n    TarHeaderLinkIndicatorType[\"NORMAL_FILE_ALT2\"] = \"\";\r\n    TarHeaderLinkIndicatorType[\"HARD_LINK\"] = \"1\";\r\n    TarHeaderLinkIndicatorType[\"SYMBOLIC_LINK\"] = \"2\";\r\n    TarHeaderLinkIndicatorType[\"CHARACTER_SPECIAL\"] = \"3\";\r\n    TarHeaderLinkIndicatorType[\"BLOCK_SPECIAL\"] = \"4\";\r\n    TarHeaderLinkIndicatorType[\"DIRECTORY\"] = \"5\";\r\n    TarHeaderLinkIndicatorType[\"FIFO\"] = \"6\";\r\n    TarHeaderLinkIndicatorType[\"CONTIGUOUS_FILE\"] = \"7\";\r\n    /**\r\n     * Global extended header with meta data (POSIX.1-2001)\r\n     */\r\n    TarHeaderLinkIndicatorType[\"GLOBAL_EXTENDED_HEADER\"] = \"g\";\r\n    /**\r\n     * Extended header with meta data for the next file in the archive (POSIX.1-2001)\r\n     */\r\n    TarHeaderLinkIndicatorType[\"LOCAL_EXTENDED_HEADER\"] = \"x\";\r\n})(TarHeaderLinkIndicatorType || (TarHeaderLinkIndicatorType = {}));\r\nexport function isTarHeaderLinkIndicatorTypeDirectory(type) {\r\n    return type === TarHeaderLinkIndicatorType.DIRECTORY;\r\n}\r\nexport function isTarHeaderLinkIndicatorTypeFile(type) {\r\n    switch (type) {\r\n        case TarHeaderLinkIndicatorType.NORMAL_FILE:\r\n        case TarHeaderLinkIndicatorType.NORMAL_FILE_ALT1:\r\n        case TarHeaderLinkIndicatorType.NORMAL_FILE_ALT2:\r\n        case TarHeaderLinkIndicatorType.CONTIGUOUS_FILE:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n", "/**\r\n * Determines how a tar header field is interpreted to and from a Uint8Array.\r\n */\r\nexport var TarHeaderFieldType;\r\n(function (TarHeaderFieldType) {\r\n    /**\r\n     * Bytes interpreted as char codes.\r\n     */\r\n    TarHeaderFieldType[\"ASCII\"] = \"ASCII\";\r\n    /**\r\n     * Bytes interpreted as char codes with spaces and trailing NUL characters.\r\n     *\r\n     * @example\r\n     * 'Test File Name.txt\\0\\0\\0\\0\\0\\0\\0....'\r\n     */\r\n    TarHeaderFieldType[\"ASCII_PADDED_END\"] = \"ASCII_PADDED_END\";\r\n    /**\r\n     * Bytes interpreted as a padded ascii octal number (i.e. ascii in range ['0' - '7']).\r\n     * USTAR format dictates that all octal integer values of this type should be front-padded with zeroes.\r\n     *\r\n     * @example\r\n     * '0000232 ' // (equates to decimal 1234)\r\n     */\r\n    TarHeaderFieldType[\"INTEGER_OCTAL\"] = \"INTEGER_OCTAL\";\r\n    /**\r\n     * Special flavor of an integer octal that also transforms the\r\n     * value by 1000x to add the milliseconds frame for a Date value.\r\n     */\r\n    TarHeaderFieldType[\"INTEGER_OCTAL_TIMESTAMP\"] = \"INTEGER_OCTAL_TIMESTAMP\";\r\n})(TarHeaderFieldType || (TarHeaderFieldType = {}));\r\n", "import { TarUtility } from '../common/tar-utility';\r\nimport { TarHeaderFieldType } from './tar-header-field-type';\r\nfunction serializeIntegerOctalTimestamp(value, field) {\r\n    return serializeIntegerOctalWithSuffix(TarUtility.encodeTimestamp(value), field, '');\r\n}\r\nfunction serializeIntegerOctal(value, field) {\r\n    return serializeIntegerOctalWithSuffix(value, field, ' ');\r\n}\r\nexport function serializeIntegerOctalWithSuffix(value, field, suffix) {\r\n    const { size } = (field || { size: 0 });\r\n    const adjustedLength = Math.max(0, size - 1 - suffix.length);\r\n    // USTAR docs indicate that value length needs to be 1 less than actual field size.\r\n    // We also need to allow for suffixes... because random white spaces.\r\n    const serializedString = TarUtility.serializeIntegerOctalToString(value, adjustedLength) + suffix;\r\n    return TarUtility.encodeString(serializedString);\r\n}\r\nconst fieldTypeTransformMap = {\r\n    [TarHeaderFieldType.ASCII]: {\r\n        serialize: TarUtility.encodeString,\r\n        deserialize: TarUtility.decodeString\r\n    },\r\n    [TarHeaderFieldType.ASCII_PADDED_END]: {\r\n        serialize: TarUtility.encodeString,\r\n        deserialize: TarUtility.deserializeAsciiPaddedField\r\n    },\r\n    [TarHeaderFieldType.INTEGER_OCTAL]: {\r\n        serialize: serializeIntegerOctal,\r\n        deserialize: TarUtility.deserializeIntegerOctal\r\n    },\r\n    [TarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP]: {\r\n        serialize: serializeIntegerOctalTimestamp,\r\n        deserialize: TarUtility.deserializeIntegerOctalTimestamp\r\n    }\r\n};\r\n/**\r\n * Definitions taken from here:\r\n * https://en.wikipedia.org/wiki/Tar_(computing)\r\n */\r\nexport class TarHeaderField {\r\n    constructor(config) {\r\n        this.name = config.name;\r\n        this.offset = config.offset;\r\n        this.size = config.size;\r\n        this.type = config.type;\r\n        this.constantValue = config.constantValue || undefined;\r\n    }\r\n    /**\r\n     * Creates an immutable field instance based on the given config.\r\n     */\r\n    static frozen(config) {\r\n        return Object.freeze(new TarHeaderField(config));\r\n    }\r\n    /**\r\n     * Shorthand for padding the output of `slice` into `decodeString`.\r\n     */\r\n    sliceString(input, offset) {\r\n        return TarUtility.decodeString(this.slice(input, offset));\r\n    }\r\n    /**\r\n     * @param input - a buffer of one or more complete tar sectors\r\n     * @param offset - the offset to slice from (must be a multiple of `SECTOR_SIZE`)\r\n     * @returns the slice of the given input Uint8Array that this field resides in.\r\n     */\r\n    slice(input, offset = 0) {\r\n        if (!TarUtility.isUint8Array(input))\r\n            return new Uint8Array(0);\r\n        const start = offset + this.offset;\r\n        const end = start + this.size;\r\n        return input.slice(start, end);\r\n    }\r\n    /**\r\n     * @param input - a buffer of one or more complete tar sectors\r\n     * @returns The value parsed from the input based on this field's transform type,\r\n     * or `undefined` on error.\r\n     */\r\n    deserialize(input) {\r\n        const transform = fieldTypeTransformMap[this.type];\r\n        return (transform && TarUtility.isUint8Array(input))\r\n            ? transform.deserialize(input, this)\r\n            : undefined;\r\n    }\r\n    /**\r\n     * @param input - the value to be serialized, based on this field's transform type.\r\n     * @returns the serialized value as a Uint8Array\r\n     */\r\n    serialize(input) {\r\n        const result = new Uint8Array(this.size);\r\n        const transform = fieldTypeTransformMap[this.type];\r\n        const value = transform.serialize(input, this);\r\n        const valueLength = TarUtility.sizeofUint8Array(value);\r\n        if (valueLength > 0 && valueLength <= this.size) {\r\n            result.set(value, 0);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n", "import { Constants } from '../common/constants';\r\nimport { TarHeaderField } from './tar-header-field';\r\nimport { TarHeaderFieldType } from './tar-header-field-type';\r\n// =====================================================================\r\n// Legacy Fields\r\n// =====================================================================\r\nexport var HeaderFieldDefinitions;\r\n(function (HeaderFieldDefinitions) {\r\n    HeaderFieldDefinitions.fileName = TarHeaderField.frozen({\r\n        name: 'fileName',\r\n        offset: 0,\r\n        size: 100,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    HeaderFieldDefinitions.fileMode = TarHeaderField.frozen({\r\n        name: 'fileMode',\r\n        offset: 100,\r\n        size: 8,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL\r\n    });\r\n    HeaderFieldDefinitions.ownerUserId = TarHeaderField.frozen({\r\n        name: 'ownerUserId',\r\n        offset: 108,\r\n        size: 8,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL\r\n    });\r\n    HeaderFieldDefinitions.groupUserId = TarHeaderField.frozen({\r\n        name: 'groupUserId',\r\n        offset: 116,\r\n        size: 8,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL\r\n    });\r\n    HeaderFieldDefinitions.fileSize = TarHeaderField.frozen({\r\n        name: 'fileSize',\r\n        offset: 124,\r\n        size: 12,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL\r\n    });\r\n    HeaderFieldDefinitions.lastModified = TarHeaderField.frozen({\r\n        name: 'lastModified',\r\n        offset: 136,\r\n        size: 12,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP\r\n    });\r\n    HeaderFieldDefinitions.headerChecksum = TarHeaderField.frozen({\r\n        name: 'headerChecksum',\r\n        offset: 148,\r\n        size: 8,\r\n        type: TarHeaderFieldType.INTEGER_OCTAL\r\n    });\r\n    HeaderFieldDefinitions.typeFlag = TarHeaderField.frozen({\r\n        name: 'typeFlag',\r\n        offset: 156,\r\n        size: 1,\r\n        type: TarHeaderFieldType.ASCII\r\n    });\r\n    HeaderFieldDefinitions.linkedFileName = TarHeaderField.frozen({\r\n        name: 'linkedFileName',\r\n        offset: 157,\r\n        size: 100,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    // =====================================================================\r\n    // USTAR Fields\r\n    // =====================================================================\r\n    HeaderFieldDefinitions.ustarIndicator = TarHeaderField.frozen({\r\n        name: 'ustarIndicator',\r\n        offset: 257,\r\n        size: 6,\r\n        type: TarHeaderFieldType.ASCII,\r\n        constantValue: Constants.USTAR_INDICATOR_VALUE\r\n    });\r\n    HeaderFieldDefinitions.ustarVersion = TarHeaderField.frozen({\r\n        name: 'ustarVersion',\r\n        offset: 263,\r\n        size: 2,\r\n        type: TarHeaderFieldType.ASCII,\r\n        constantValue: Constants.USTAR_VERSION_VALUE\r\n    });\r\n    HeaderFieldDefinitions.ownerUserName = TarHeaderField.frozen({\r\n        name: 'ownerUserName',\r\n        offset: 265,\r\n        size: 32,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    HeaderFieldDefinitions.ownerGroupName = TarHeaderField.frozen({\r\n        name: 'ownerGroupName',\r\n        offset: 297,\r\n        size: 32,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    HeaderFieldDefinitions.deviceMajorNumber = TarHeaderField.frozen({\r\n        name: 'deviceMajorNumber',\r\n        offset: 329,\r\n        size: 8,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    HeaderFieldDefinitions.deviceMinorNumber = TarHeaderField.frozen({\r\n        name: 'deviceMinorNumber',\r\n        offset: 337,\r\n        size: 8,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    HeaderFieldDefinitions.fileNamePrefix = TarHeaderField.frozen({\r\n        name: 'fileNamePrefix',\r\n        offset: 345,\r\n        size: 155,\r\n        type: TarHeaderFieldType.ASCII_PADDED_END\r\n    });\r\n    const fieldsByName = {\r\n        fileName: HeaderFieldDefinitions.fileName,\r\n        fileMode: HeaderFieldDefinitions.fileMode,\r\n        ownerUserId: HeaderFieldDefinitions.ownerUserId,\r\n        groupUserId: HeaderFieldDefinitions.groupUserId,\r\n        fileSize: HeaderFieldDefinitions.fileSize,\r\n        lastModified: HeaderFieldDefinitions.lastModified,\r\n        headerChecksum: HeaderFieldDefinitions.headerChecksum,\r\n        typeFlag: HeaderFieldDefinitions.typeFlag,\r\n        linkedFileName: HeaderFieldDefinitions.linkedFileName,\r\n        ustarIndicator: HeaderFieldDefinitions.ustarIndicator,\r\n        ustarVersion: HeaderFieldDefinitions.ustarVersion,\r\n        ownerUserName: HeaderFieldDefinitions.ownerUserName,\r\n        ownerGroupName: HeaderFieldDefinitions.ownerGroupName,\r\n        deviceMajorNumber: HeaderFieldDefinitions.deviceMajorNumber,\r\n        deviceMinorNumber: HeaderFieldDefinitions.deviceMinorNumber,\r\n        fileNamePrefix: HeaderFieldDefinitions.fileNamePrefix\r\n    };\r\n    function orderedSet() {\r\n        return Object.values(fieldsByName);\r\n    }\r\n    HeaderFieldDefinitions.orderedSet = orderedSet;\r\n    function checksumSet() {\r\n        return orderedSet().filter(v => v !== HeaderFieldDefinitions.headerChecksum);\r\n    }\r\n    HeaderFieldDefinitions.checksumSet = checksumSet;\r\n    function isUstarSector(input, offset) {\r\n        return HeaderFieldDefinitions.ustarIndicator.sliceString(input, offset).startsWith(Constants.USTAR_TAG);\r\n    }\r\n    HeaderFieldDefinitions.isUstarSector = isUstarSector;\r\n})(HeaderFieldDefinitions || (HeaderFieldDefinitions = {}));\r\n", "import { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { HeaderFieldDefinitions } from './tar-header-field-definitions';\r\nimport { TarHeaderLinkIndicatorType } from './tar-header-link-indicator-type';\r\nconst { checksumSet, headerChecksum, orderedSet } = HeaderFieldDefinitions;\r\nconst CHECKSUM_SEED_STRING = ''.padStart(headerChecksum.size, ' ');\r\nconst CHECKSUM_SEED = TarUtility.generateChecksum(TarUtility.encodeString(CHECKSUM_SEED_STRING));\r\nconst ALL_FIELDS = orderedSet();\r\nconst CHECKSUM_FIELDS = checksumSet();\r\nexport function sanitizeHeader(header) {\r\n    if (header && TarUtility.isNumber(header.lastModified)) {\r\n        header.lastModified = TarUtility.sanitizeTimestamp(header.lastModified);\r\n    }\r\n    return Object.assign(getDefaultHeaderValues(), (header || {}));\r\n}\r\nexport function getDefaultHeaderValues() {\r\n    return {\r\n        fileName: '',\r\n        fileMode: Constants.FILE_MODE_DEFAULT,\r\n        groupUserId: 0,\r\n        ownerUserId: 0,\r\n        fileSize: 0,\r\n        lastModified: TarUtility.sanitizeTimestamp(Date.now()),\r\n        headerChecksum: 0,\r\n        linkedFileName: '',\r\n        typeFlag: TarHeaderLinkIndicatorType.NORMAL_FILE,\r\n        ustarIndicator: Constants.USTAR_INDICATOR_VALUE,\r\n        ustarVersion: Constants.USTAR_VERSION_VALUE,\r\n        ownerUserName: '',\r\n        ownerGroupName: '',\r\n        deviceMajorNumber: '00',\r\n        deviceMinorNumber: '00',\r\n        fileNamePrefix: ''\r\n    };\r\n}\r\n/**\r\n * Expanded version of a TarHeader that contains both the\r\n * serialized and deserialized state of each field.\r\n */\r\nexport class TarHeaderMetadata {\r\n    constructor(input = getDefaultHeaderValues()) {\r\n        this.inflate(input);\r\n    }\r\n    /**\r\n     * Shorthand for populating a new instance and immediately\r\n     * collapsing it with `toUint8Array()`.\r\n     */\r\n    static serialize(input) {\r\n        return new TarHeaderMetadata(input).toUint8Array();\r\n    }\r\n    /**\r\n     * Shorthand for populating a new instance and immediately\r\n     * collapsing it with `deflate()`.\r\n     */\r\n    static deflateFrom(input, offset) {\r\n        return TarHeaderMetadata.from(input, offset).deflate();\r\n    }\r\n    /**\r\n     * Extracts all known header fields from the given input buffer, at the given offset.\r\n     *\r\n     * NOTE: this does not check if the buffer at the given offset is actually a ustar sector, and\r\n     * it is up to the caller to make this check.\r\n     */\r\n    static from(input, offset) {\r\n        const result = new TarHeaderMetadata();\r\n        if (TarUtility.isUint8Array(input))\r\n            for (const field of ALL_FIELDS)\r\n                result.setSerializedField(field, input, offset);\r\n        return result;\r\n    }\r\n    setDeserializedFieldFrom(field, header) {\r\n        return this.setDeserializedField(field, header[field.name]);\r\n    }\r\n    setDeserializedField(field, value) {\r\n        const bytes = field.serialize(value);\r\n        const result = this[field.name] = { field, bytes, value };\r\n        return result;\r\n    }\r\n    setSerializedField(field, input, offset = 0) {\r\n        const bytes = field.slice(input, offset);\r\n        const value = field.deserialize(bytes);\r\n        const result = this[field.name] = { field, bytes, value };\r\n        return result;\r\n    }\r\n    /**\r\n     * Same as `inflate()`, but seeds the input with the values currently\r\n     * set on this instance as defaults.\r\n     */\r\n    update(input) {\r\n        const snapshot = Object.assign(this.deflate(), input);\r\n        return this.inflate(snapshot);\r\n    }\r\n    /**\r\n     * Overwrite this instance's fields with the given header values.\r\n     */\r\n    inflate(input) {\r\n        const normalizedHeader = sanitizeHeader(input);\r\n        let checksum = CHECKSUM_SEED;\r\n        for (const field of CHECKSUM_FIELDS) {\r\n            const { bytes } = this.setDeserializedFieldFrom(field, normalizedHeader);\r\n            checksum += TarUtility.generateChecksum(bytes);\r\n        }\r\n        this.setDeserializedField(headerChecksum, checksum);\r\n        return this;\r\n    }\r\n    /**\r\n     * Generate a TarHeader snapshot from this instance's current state.\r\n     */\r\n    deflate() {\r\n        const result = {};\r\n        for (const field of ALL_FIELDS) {\r\n            result[field.name] = this[field.name].value;\r\n        }\r\n        return sanitizeHeader(result);\r\n    }\r\n    /**\r\n     * Creates a USTAR sector buffer using the currently set header values.\r\n     * NOTE: missing fields will be auto-populated with default values.\r\n     */\r\n    toUint8Array() {\r\n        const headerBuffer = new Uint8Array(Constants.HEADER_SIZE);\r\n        for (const field of ALL_FIELDS) {\r\n            const { bytes } = this[field.name];\r\n            headerBuffer.set(bytes, field.offset);\r\n        }\r\n        return headerBuffer;\r\n    }\r\n}\r\n", "import { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { sanitizeHeader, TarHeaderMetadata } from '../header/tar-header-metadata';\r\nfunction concatAttributes(accumulator, attrs) {\r\n    return TarUtility.concatUint8Arrays(accumulator, attrs.toUint8Array());\r\n}\r\n/**\r\n * Deflated snapshot of an entry with _no_ metadata built-in.\r\n * Counterpart to `TarEntryMetadata`.\r\n */\r\nexport class TarEntryAttributes {\r\n    constructor(header, content = null) {\r\n        this.header = header;\r\n        this.content = content;\r\n    }\r\n    static from(value) {\r\n        const { header, content } = value;\r\n        return new TarEntryAttributes(header, content);\r\n    }\r\n    static fromMany(values) {\r\n        return Array.from(values).filter(v => !!v).map(v => TarEntryAttributes.from(v));\r\n    }\r\n    static combine(snapshots) {\r\n        return snapshots.reduce(concatAttributes, new Uint8Array(0));\r\n    }\r\n    static combinePadded(snapshots) {\r\n        const padBuffer = new Uint8Array(Constants.SECTOR_SIZE * 2);\r\n        return TarUtility.concatUint8Arrays(TarEntryAttributes.combine(snapshots), padBuffer);\r\n    }\r\n    static combinePaddedFrom(snapshots) {\r\n        const parsedAttrs = TarEntryAttributes.fromMany(snapshots);\r\n        return TarEntryAttributes.combinePadded(parsedAttrs);\r\n    }\r\n    toUint8Array() {\r\n        const { header, content } = this;\r\n        const contentSize = TarUtility.sizeofUint8Array(content);\r\n        const offsetDelta = TarUtility.getSectorOffsetDelta(contentSize);\r\n        let paddedContent = content;\r\n        if (contentSize > 0 && offsetDelta > 0) {\r\n            paddedContent = TarUtility.concatUint8Arrays(content, new Uint8Array(offsetDelta));\r\n        }\r\n        const safeHeader = sanitizeHeader(header);\r\n        safeHeader.fileSize = contentSize;\r\n        const headerBuffer = TarHeaderMetadata.serialize(safeHeader);\r\n        return TarUtility.concatUint8Arrays(headerBuffer, paddedContent);\r\n    }\r\n}\r\n", "import { __awaiter } from \"tslib\";\r\nimport { findInAsyncUint8Array } from '../common/async-uint8array';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { HeaderFieldDefinitions } from '../header/tar-header-field-definitions';\r\nimport { TarHeaderMetadata } from '../header/tar-header-metadata';\r\n/**\r\n * Searches through the given AsyncUint8Array for the next USTAR sector,\r\n * starting at the given offset.\r\n */\r\nexport function findNextUstarSectorAsync(input, offset = 0) {\r\n    return findInAsyncUint8Array(input, offset, 1, value => HeaderFieldDefinitions.isUstarSector(value));\r\n}\r\n/**\r\n * Searches the given input buffer for a USTAR header tar sector, starting at the given offset.\r\n * Returns -1 if no valid header sector is found.\r\n */\r\nexport function findNextUstarSectorOffset(input, offset = 0) {\r\n    const NOT_FOUND = -1;\r\n    if (!TarUtility.isUint8Array(input)) {\r\n        return NOT_FOUND;\r\n    }\r\n    const maxOffset = input.byteLength;\r\n    let nextOffset = Math.max(0, offset);\r\n    while (nextOffset < maxOffset && !HeaderFieldDefinitions.isUstarSector(input, nextOffset)) {\r\n        nextOffset = TarUtility.advanceSectorOffset(nextOffset, maxOffset);\r\n    }\r\n    if (nextOffset < maxOffset) {\r\n        return nextOffset;\r\n    }\r\n    return NOT_FOUND;\r\n}\r\n/**\r\n * Entry data parsed from a buffer, with header metadata built-in.\r\n * Counterpart to `TarEntryAttributes`.\r\n */\r\nexport class TarEntryMetadata {\r\n    constructor(header, content, offset) {\r\n        this.header = header;\r\n        this.content = content;\r\n        this.offset = offset;\r\n    }\r\n    static isTarEntryMetadata(value) {\r\n        return !!(value && (value instanceof TarEntryMetadata));\r\n    }\r\n    static from(value) {\r\n        if (TarEntryMetadata.isTarEntryMetadata(value))\r\n            return value;\r\n        let { header, content, offset } = (value || {});\r\n        if (!header)\r\n            header = new TarHeaderMetadata();\r\n        if (!content)\r\n            content = null;\r\n        if (!offset)\r\n            offset = 0;\r\n        const contentLength = TarUtility.sizeofUint8Array(content);\r\n        // The fileSize field metadata must always be in sync between the content and the header\r\n        if (header.fileSize.value !== contentLength && contentLength > 0) {\r\n            header.update({ fileSize: contentLength });\r\n        }\r\n        return new TarEntryMetadata(header, content, offset);\r\n    }\r\n    /**\r\n     * Searches through the given input buffer for the next tar entry, starting at the given offset.\r\n     * Does not modify the input buffer.\r\n     */\r\n    static extractFrom(input, offset = 0) {\r\n        if (!TarUtility.isUint8Array(input)) {\r\n            return null;\r\n        }\r\n        const ustarSectorOffset = findNextUstarSectorOffset(input, offset);\r\n        if (ustarSectorOffset < 0) {\r\n            return null;\r\n        }\r\n        const maxOffset = input.byteLength;\r\n        const header = TarHeaderMetadata.from(input, ustarSectorOffset);\r\n        const start = TarUtility.advanceSectorOffset(ustarSectorOffset, maxOffset);\r\n        const fileSize = header.fileSize.value;\r\n        let content = null;\r\n        if (TarUtility.isNumber(fileSize) && fileSize > 0) {\r\n            const end = Math.min(maxOffset, start + fileSize);\r\n            content = input.slice(start, end);\r\n        }\r\n        return new TarEntryMetadata(header, content, ustarSectorOffset);\r\n    }\r\n    /**\r\n     * Searches through the given AsyncUint8Array for the next available tar entry from the given offset.\r\n     *\r\n     * NOTE: Unlike `extractFrom()`, this does not try to load the file content into memory and\r\n     * assumes that the entry may be a file that is too large to load. It is up to the caller to\r\n     * load this content if needed.\r\n     */\r\n    static extractFromAsync(input, offset = 0) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!input) {\r\n                return null;\r\n            }\r\n            const sector = yield findNextUstarSectorAsync(input, offset);\r\n            if (!sector) {\r\n                return null;\r\n            }\r\n            const { value, offset: ustarSectorOffset } = sector;\r\n            const header = TarHeaderMetadata.from(value);\r\n            const content = null;\r\n            return new TarEntryMetadata(header, content, ustarSectorOffset);\r\n        });\r\n    }\r\n}\r\n", "import { __awaiter } from \"tslib\";\r\nimport { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { isTarHeaderLinkIndicatorTypeDirectory, isTarHeaderLinkIndicatorTypeFile } from '../header/tar-header-link-indicator-type';\r\nimport { TarHeaderMetadata } from '../header/tar-header-metadata';\r\nimport { TarEntryAttributes } from './tar-entry-attributes';\r\nimport { TarEntryMetadata } from './tar-entry-metadata';\r\n/**\r\n * Container for metadata and content of a tarball entry.\r\n *\r\n * Here, we consider an \"entry\" to be a tuple of:\r\n * 1. The parsed USTAR header sector content (AKA TarHeader)\r\n * 2. The aggregate of the proceeding file content sectors, based on the header's file size attribute\r\n */\r\nexport class TarEntry {\r\n    constructor(metadata) {\r\n        this.metadata = TarEntryMetadata.from(metadata);\r\n    }\r\n    static isTarEntry(v) {\r\n        return !!(v && v instanceof TarEntry);\r\n    }\r\n    static from(attrs, content = null) {\r\n        const header = new TarHeaderMetadata(attrs);\r\n        return new TarEntry({ header, content, offset: 0 });\r\n    }\r\n    static fromAttributes(attrs) {\r\n        const { header, content } = attrs;\r\n        return TarEntry.from(header, content);\r\n    }\r\n    static tryParse(input, offset) {\r\n        const metadata = TarEntryMetadata.extractFrom(input, offset);\r\n        return metadata ? new TarEntry(metadata) : null;\r\n    }\r\n    static tryParseAsync(input, offset) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const metadata = yield TarEntryMetadata.extractFromAsync(input, offset);\r\n            return metadata ? new TarEntry(metadata) : null;\r\n        });\r\n    }\r\n    // =================================================================\r\n    // TarHeader Interface Fields\r\n    // =================================================================\r\n    get fileName() {\r\n        return this.header.fileName.value;\r\n    }\r\n    set fileName(value) {\r\n        this.header.fileName.value = value;\r\n    }\r\n    get fileSize() {\r\n        return this.header.fileSize.value;\r\n    }\r\n    set fileSize(value) {\r\n        this.header.fileSize.value = value;\r\n    }\r\n    get fileMode() {\r\n        return this.header.fileMode.value;\r\n    }\r\n    set fileMode(value) {\r\n        this.header.fileMode.value = value;\r\n    }\r\n    get ownerUserId() {\r\n        return this.header.ownerUserId.value;\r\n    }\r\n    set ownerUserId(value) {\r\n        this.header.ownerUserId.value = value;\r\n    }\r\n    get groupUserId() {\r\n        return this.header.groupUserId.value;\r\n    }\r\n    set groupUserId(value) {\r\n        this.header.groupUserId.value = value;\r\n    }\r\n    get lastModified() {\r\n        return this.header.lastModified.value;\r\n    }\r\n    set lastModified(value) {\r\n        this.header.lastModified.value = value;\r\n    }\r\n    get headerChecksum() {\r\n        return this.header.headerChecksum.value;\r\n    }\r\n    get linkedFileName() {\r\n        return this.header.linkedFileName.value;\r\n    }\r\n    set linkedFileName(value) {\r\n        this.header.linkedFileName.value = value;\r\n    }\r\n    get typeFlag() {\r\n        return this.header.typeFlag.value;\r\n    }\r\n    set typeFlag(value) {\r\n        this.header.typeFlag.value = value;\r\n    }\r\n    get ustarIndicator() {\r\n        return this.header.ustarIndicator.value;\r\n    }\r\n    get ustarVersion() {\r\n        return this.header.ustarVersion.value;\r\n    }\r\n    set ustarVersion(value) {\r\n        this.header.ustarVersion.value = value;\r\n    }\r\n    get ownerUserName() {\r\n        return this.header.ownerUserName.value;\r\n    }\r\n    set ownerUserName(value) {\r\n        this.header.ownerUserName.value = value;\r\n    }\r\n    get ownerGroupName() {\r\n        return this.header.ownerGroupName.value;\r\n    }\r\n    set ownerGroupName(value) {\r\n        this.header.ownerGroupName.value = value;\r\n    }\r\n    get deviceMajorNumber() {\r\n        return this.header.deviceMajorNumber.value;\r\n    }\r\n    set deviceMajorNumber(value) {\r\n        this.header.deviceMajorNumber.value = value;\r\n    }\r\n    get deviceMinorNumber() {\r\n        return this.header.deviceMinorNumber.value;\r\n    }\r\n    set deviceMinorNumber(value) {\r\n        this.header.deviceMinorNumber.value = value;\r\n    }\r\n    get fileNamePrefix() {\r\n        return this.header.fileNamePrefix.value;\r\n    }\r\n    set fileNamePrefix(value) {\r\n        this.header.fileNamePrefix.value = value;\r\n    }\r\n    // =================================================================\r\n    // Introspection Fields\r\n    // =================================================================\r\n    /**\r\n     * The header metadata parsed out for this entry.\r\n     * See TarHeaderFieldDefinition for details.\r\n     */\r\n    get header() {\r\n        return this.metadata.header;\r\n    }\r\n    /**\r\n     * The file content for this entry.\r\n     * This may be null for entries loaded asynchronously, or\r\n     * for non-file entries like directories.\r\n     */\r\n    get content() {\r\n        return this.metadata.content;\r\n    }\r\n    /**\r\n     * The starting absolute index (inclusive) in the source buffer that this entry was parsed from.\r\n     * Returns zero by default if this was not parsed by a source buffer.\r\n     */\r\n    get bufferStartIndex() {\r\n        return this.metadata.offset;\r\n    }\r\n    /**\r\n     * The ending absolute index (exclusive) in the source buffer that this entry was parsed from.\r\n     * Returns sectorByteLength by default if this was not parsed by a source buffer.\r\n     */\r\n    get bufferEndIndex() {\r\n        return this.bufferStartIndex + this.sectorByteLength;\r\n    }\r\n    /**\r\n     * The total exact byte length of this entry, including the header.\r\n     */\r\n    get byteLength() {\r\n        return Constants.HEADER_SIZE + this.fileSize;\r\n    }\r\n    /**\r\n     * The total byte length of this entry, including the header,\r\n     * which is a multiple of the standard tar sector size.\r\n     */\r\n    get sectorByteLength() {\r\n        return TarUtility.roundUpSectorOffset(this.byteLength);\r\n    }\r\n    /**\r\n     * The starting index (inclusive) of the content of this entry.\r\n     * Note that this will always be the first index of the header, regardless of\r\n     * whether or not this is a file.\r\n     */\r\n    get contentStartIndex() {\r\n        return Constants.HEADER_SIZE + this.bufferStartIndex;\r\n    }\r\n    /**\r\n     * The ending index (exclusive) of the content of this entry.\r\n     * If this entry is not a file, or the file is empty, this will be\r\n     * the same as the content starting index.\r\n     */\r\n    get contentEndIndex() {\r\n        return this.contentStartIndex + this.fileSize;\r\n    }\r\n    getContentAsText() {\r\n        return TarUtility.decodeString(this.content);\r\n    }\r\n    isDirectory() {\r\n        return isTarHeaderLinkIndicatorTypeDirectory(this.typeFlag);\r\n    }\r\n    isFile() {\r\n        return isTarHeaderLinkIndicatorTypeFile(this.typeFlag);\r\n    }\r\n    /**\r\n     * Only necessary if this entry was extracted from an async buffer, since the entry\r\n     * does not hold the content of async buffers by default.\r\n     *\r\n     * If the entry was extracted synchronously, its content will be available via the \"content\" property.\r\n     */\r\n    readContentFrom(buffer, offset = 0, length = 0) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { contentStartIndex, contentEndIndex, fileSize } = this;\r\n            const normalizedOffset = TarUtility.clamp(offset, 0, fileSize) + contentStartIndex;\r\n            const bytesRemaining = Math.max(0, contentEndIndex - normalizedOffset);\r\n            const normalizedLength = length > 0 ? Math.min(length, bytesRemaining) : bytesRemaining;\r\n            return buffer.read(normalizedOffset, normalizedLength);\r\n        });\r\n    }\r\n    toAttributes() {\r\n        return new TarEntryAttributes(this.header.deflate(), this.content);\r\n    }\r\n    toUint8Array() {\r\n        return this.toAttributes().toUint8Array();\r\n    }\r\n    /**\r\n     * Overridden to prevent circular reference errors / huge memory spikes that would\r\n     * include the underlying content by default.\r\n     */\r\n    toJSON() {\r\n        const { header, fileName, fileSize } = this;\r\n        const isFile = this.isFile();\r\n        const isDirectory = this.isDirectory();\r\n        const content = this.content\r\n            ? ('Uint8Array[' + this.content.byteLength + ']')\r\n            : 'null';\r\n        return {\r\n            content,\r\n            fileName,\r\n            fileSize,\r\n            isFile,\r\n            isDirectory,\r\n            header\r\n        };\r\n    }\r\n}\r\n", "import { TarUtility } from '../common/tar-utility';\r\n/**\r\n * Shared logic between async and sync iterators.\r\n */\r\nexport class TarEntryIteratorBase {\r\n    constructor() {\r\n        this.mOffset = 0;\r\n        this.mSize = 0;\r\n    }\r\n    get defaultIteratorResult() {\r\n        return { value: null, done: true };\r\n    }\r\n    get bufferOffset() {\r\n        return this.mOffset;\r\n    }\r\n    set bufferOffset(value) {\r\n        this.mOffset = TarUtility.clamp(value, 0, this.bufferLength);\r\n    }\r\n    get bufferLength() {\r\n        return this.mSize;\r\n    }\r\n    set bufferLength(value) {\r\n        this.mSize = Math.max(0, value);\r\n    }\r\n    canAdvanceOffset() {\r\n        return this.bufferOffset < this.bufferLength;\r\n    }\r\n    toJSON() {\r\n        const { bufferOffset, bufferLength } = this;\r\n        const canAdvanceOffset = this.canAdvanceOffset();\r\n        return { bufferOffset, bufferLength, canAdvanceOffset };\r\n    }\r\n    consumeIteratorResult(entry) {\r\n        if (!entry) {\r\n            return this.defaultIteratorResult;\r\n        }\r\n        this.bufferOffset = entry.bufferEndIndex;\r\n        const value = entry;\r\n        const done = !this.canAdvanceOffset();\r\n        return { value, done };\r\n    }\r\n}\r\n", "import { __asyncValues, __awaiter } from \"tslib\";\r\nimport { TarEntry } from './tar-entry';\r\nimport { TarEntryIteratorBase } from './tar-entry-iterator-base';\r\n/**\r\n * Utility for stepping through a given byte buffer and extracting tar files one-at-a-time.\r\n *\r\n * Call the initialize() the Uint8Array data of a tar file, and then either:\r\n * A) step through the files using next() manually, or\r\n * B) get all the files at once with Array.from()\r\n */\r\nexport class AsyncTarEntryIterator extends TarEntryIteratorBase {\r\n    constructor() {\r\n        super();\r\n        this.initialize(null);\r\n    }\r\n    /**\r\n     * Convenience to step through entries one-at-a-time, without collecting them.\r\n     * Helps to emulate \"streaming\" functionality that other tar modules have.\r\n     */\r\n    static forEachIn(buffer, onNext) {\r\n        var _a, e_1, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const iterator = new AsyncTarEntryIterator();\r\n            yield iterator.initialize(buffer);\r\n            let i = 0;\r\n            try {\r\n                for (var _d = true, iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = yield iterator_1.next(), _a = iterator_1_1.done, !_a;) {\r\n                    _c = iterator_1_1.value;\r\n                    _d = false;\r\n                    try {\r\n                        const entry = _c;\r\n                        yield onNext(entry, i, buffer);\r\n                        i++;\r\n                    }\r\n                    finally {\r\n                        _d = true;\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (!_d && !_a && (_b = iterator_1.return)) yield _b.call(iterator_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Convenience to parse out all entries in one go.\r\n     */\r\n    static extractAll(buffer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            yield AsyncTarEntryIterator.forEachIn(buffer, (entry) => __awaiter(this, void 0, void 0, function* () {\r\n                result.push(entry);\r\n            }));\r\n            return result;\r\n        });\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return this;\r\n    }\r\n    next() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.canAdvanceOffset()\r\n                ? this.consumeIteratorResult(yield TarEntry.tryParseAsync(this.mData, this.bufferOffset))\r\n                : this.defaultIteratorResult;\r\n        });\r\n    }\r\n    initialize(data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (data) {\r\n                this.mData = data;\r\n                this.bufferLength = yield this.mData.byteLength();\r\n            }\r\n            else {\r\n                this.mData = null;\r\n                this.bufferLength = 0;\r\n            }\r\n            this.bufferOffset = 0;\r\n        });\r\n    }\r\n}\r\n", "import { TarUtility } from '../common/tar-utility';\r\nimport { TarEntry } from './tar-entry';\r\nimport { TarEntryIteratorBase } from './tar-entry-iterator-base';\r\n/**\r\n * Utility for stepping through a given byte buffer and extracting tar files one-at-a-time.\r\n *\r\n * Call the initialize() the Uint8Array data of a tar file, and then either:\r\n * A) step through the files using next() manually, or\r\n * B) get all the files at once with Array.from()\r\n */\r\nexport class TarEntryIterator extends TarEntryIteratorBase {\r\n    constructor() {\r\n        super();\r\n        this.initialize(null);\r\n    }\r\n    /**\r\n     * Convenience to parse out all entries in one go.\r\n     */\r\n    static extractAll(buffer) {\r\n        const iterator = new TarEntryIterator();\r\n        iterator.initialize(buffer);\r\n        return Array.from(iterator);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return this;\r\n    }\r\n    next() {\r\n        return this.canAdvanceOffset()\r\n            ? this.consumeIteratorResult(TarEntry.tryParse(this.mData, this.bufferOffset))\r\n            : this.defaultIteratorResult;\r\n    }\r\n    initialize(data) {\r\n        if (TarUtility.isUint8Array(data)) {\r\n            this.mData = data;\r\n            this.bufferLength = this.mData.byteLength;\r\n        }\r\n        else {\r\n            this.mData = null;\r\n            this.bufferLength = 0;\r\n        }\r\n        this.bufferOffset = 0;\r\n    }\r\n}\r\n", "import { __awaiter } from \"tslib\";\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { AsyncTarEntryIterator } from '../entry/async-tar-entry-iterator';\r\nimport { TarEntry } from '../entry/tar-entry';\r\nimport { TarEntryAttributes } from '../entry/tar-entry-attributes';\r\nimport { TarEntryIterator } from '../entry/tar-entry-iterator';\r\nimport { TarHeaderLinkIndicatorType } from '../header/tar-header-link-indicator-type';\r\n/**\r\n * Main entry point for extracting and creating tarballs.\r\n * See TarIterator and TarEntry for more granular options.\r\n */\r\nexport class Tarball {\r\n    constructor() {\r\n        this.entries = [];\r\n    }\r\n    /**\r\n     * Parses a set of TarEntry instances from the given buffer.\r\n     * The buffer should come from a complete, uncompressed tar file.\r\n     */\r\n    static extract(buffer) {\r\n        return TarEntryIterator.extractAll(buffer);\r\n    }\r\n    /**\r\n     * Generates a tar file buffer from the given attributes list.\r\n     */\r\n    static create(entries) {\r\n        return TarEntryAttributes.combinePaddedFrom(entries);\r\n    }\r\n    /**\r\n     * Parses a set of TarEntry instances from the given async buffer.\r\n     * The buffer should come from a complete, uncompressed tar file.\r\n     */\r\n    static extractAsync(buffer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return AsyncTarEntryIterator.extractAll(buffer);\r\n        });\r\n    }\r\n    /**\r\n     * Step through entries as they are parsed from the source.\r\n     * Does not collect entries into an array, and is generally more\r\n     * memory-friendly.\r\n     */\r\n    static streamAsync(buffer, onNext) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return AsyncTarEntryIterator.forEachIn(buffer, onNext);\r\n        });\r\n    }\r\n    toUint8Array() {\r\n        const attrs = Array.from(this.entries).map(e => e.toAttributes());\r\n        return Tarball.create(attrs);\r\n    }\r\n    setBuffer(buffer) {\r\n        this.entries = Tarball.extract(buffer);\r\n        return this;\r\n    }\r\n    add(attrs) {\r\n        this.entries.push(TarEntry.fromAttributes(attrs));\r\n        return this;\r\n    }\r\n    addTextFile(path, content, headerOptions) {\r\n        return this.addBinaryFile(path, TarUtility.encodeString(content), headerOptions);\r\n    }\r\n    addBinaryFile(path, content, headerOptions = {}) {\r\n        return this.add({\r\n            header: Object.assign({\r\n                fileName: path,\r\n                fileSize: content.byteLength,\r\n                typeFlag: TarHeaderLinkIndicatorType.NORMAL_FILE\r\n            }, headerOptions),\r\n            content\r\n        });\r\n    }\r\n    addDirectory(path, headerOptions = {}) {\r\n        return this.add({\r\n            header: Object.assign({\r\n                fileName: path,\r\n                typeFlag: TarHeaderLinkIndicatorType.DIRECTORY\r\n            }, headerOptions)\r\n        });\r\n    }\r\n}\r\n", "// Decodes a LZW-encoded buffer (LSB first)\n// Taken from https://cs.opensource.google/go/go/+/refs/tags/go1.21.3:src/compress/lzw/reader.go;l=254\n\nconst maxWidth = 12\nconst decoderInvalidCode = 0xffff\nconst flushBuffer = 1 << maxWidth\n\n// IO primitive\nexport enum IOErrors {\n    EOF = \"EOF\",\n    UnexpectedEOF = \"unexpected EOF\"\n}\n\nexport enum Order {\n    LSB,\n    MSB\n}\n\n// io.ByteReader from Golang [https://cs.opensource.google/go/go/+/refs/tags/go1.21.3:src/compress/lzw/reader.go;l=48]\nexport class ByteWReader {\n    private buf: Uint8Array\n\n    constructor(buf: Uint8Array) {\n        this.buf = buf\n    }\n\n    // getBuffer returns the buffer\n    // Not present in Go\n    jsGetInnerArray(): Uint8Array {\n        return this.buf\n    }\n\n    jsConcat(buf: Uint8Array) {\n        this.buf = Uint8Array.from([...this.buf, ...buf])\n    }\n\n    // readByte reads the next byte from the input buffer.\n    // Equivalent to r.ReadByte() in io.ByteReader\n    ReadByte(): [number, Error | null] {\n        if (this.buf.length == 0) {\n            return [0, new Error(IOErrors.EOF)]\n        }\n\n        let b = this.buf[0]\n        this.buf = this.buf.subarray(1)\n        return [b, null]\n    }\n\n    // Copy copies bytes from src to dst. It returns the number of bytes copied\n    // Equivalent to copy in Go\n    Copy(bytes: number[]): number {\n        console.log(\"copyToBuf\", bytes, this.buf)\n        this.buf = Uint8Array.from([...this.buf, ...bytes])\n\n        console.log(\"Array length\", this.buf, this.buf.length)\n\n        return bytes.length\n    }\n}\n\nexport class LZWReader {\n    r: ByteWReader\n    bits: number = 0 // uint32\n    nBits: number = 0// uint\n    width: number = 0 // uint\n    litWidth: number = 0 // uint\n\n\t// The first 1<<litWidth codes are literal codes.\n\t// The next two codes mean clear and EOF.\n\t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n\t// with the upper bound incrementing on each code seen.\n\t//\n\t// overflow is the code at which hi overflows the code width. It always\n\t// equals 1 << width.\n\t//\n\t// last is the most recently seen code, or decoderInvalidCode.\n\t//\n\t// An invariant is that hi < overflow.\n    clear: number = 0 // uint\n    eof: number = 0 // uint\n    hi: number = 0 // uint\n    overflow: number = 0 // uint\n    last: number = 0 // uint\n\n    err: Error // Error in the stream, if any\n\n\t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n\t//   suffix[c] is the last of these bytes.\n\t//   prefix[c] is the code for all but the last byte.\n\t//   This code can either be a literal code or another code in [lo, c).\n\t// The c == hi case is a special case.\n    suffix: number[] = [] // [1 << maxWidth]uint8\n    prefix: number[] = [] // [1 << maxWidth]uint16\n\n\t// output is the temporary output buffer.\n\t// Literal codes are accumulated from the start of the buffer.\n\t// Non-literal codes decode to a sequence of suffixes that are first\n\t// written right-to-left from the end of the buffer before being copied\n\t// to the start of the buffer.\n\t// It is flushed when it contains >= 1<<maxWidth bytes,\n\t// so that there is always room to decode an entire code.\n    output: number[] = [] // [1 << maxWidth]byte\n    o = 0 // write index into output\n    toRead: number[] = [] // bytes to return from Read\n\n    // Not present in the go code\n    order: Order = Order.LSB // uint\n\n    constructor(src: ByteWReader, order: Order, litWidth: number) {        \n        if(litWidth < 2 || 8 < litWidth) {\n            throw new Error(\"lzw: litWidth out of range\")\n        }\n\n        this.order = order\n        this.r = src\n        this.litWidth = litWidth\n        this.width = 1 + litWidth\n        this.clear = 1 << litWidth\n        this.eof = this.clear + 1 // r.eof, r.hi = r.clear+1, r.clear+1\n        this.hi = this.clear + 1\n        this.overflow = 1 << this.width\n        this.last = decoderInvalidCode   \n        \n        // Set up the initial slices [js specific]\n        this.suffix = Array.from({ length: 1 << maxWidth }, () => 0)\n        this.prefix = Array.from({ length: 1 << maxWidth }, () => 0)\n        this.output = Array.from({ length: 2 * (1 << maxWidth) }, () => 0)\n    }\n\n    // Not present in the Go code\n    //\n    // readLSB or readMSB\n    //\n    // This is slightly more idiomatic than defining a function in the class\n    private read(): [number /* uint16 */, Error | null] {\n        switch (this.order) {\n            case Order.LSB:\n                return this.readLSB()\n            case Order.MSB:\n                return this.readMSB()\n            default:\n                return [0, new Error(\"lzw: invalid order\")]\n        }\n    }\n\n    // readLSB returns the next code for \"Least Significant Bits first\" data.\n    private readLSB(): [number /* uint16 */, Error | null] {\n        while (this.nBits < this.width) {\n            let [x, err] = this.r.ReadByte()\n\n            if (err) {\n                return [0, err]\n            }\n\n            this.bits |= (x << this.nBits)\n            this.nBits += 8\n        }\n\n        let code = this.bits & ((1<<this.width) - 1)\n        this.bits >>= this.width\n        this.nBits -= this.width\n        return [code, null]\n    }\n\n    // readMSB returns the next code for \"Most Significant Bits first\" data.\n    private readMSB(): [number /* uint16 */, Error | null] {\n        while (this.nBits < this.width) {\n            let [x, err] = this.r.ReadByte()\n\n            if (err) {\n                return [0, err]\n            }\n\n            this.bits |= (x) << (24 - this.nBits)\n\n            this.nBits += 8\n        }\n\n        let code = this.bits >> (32 - this.width)\n        this.bits <<= this.width\n        this.nBits -= this.width\n        return [code, null]\n    }\n\n    // The Read function is not implemented here the same way as it is Go-specific\n    //\n    // Read implements io.Reader, reading uncompressed bytes from its underlying Reader.\n    Read(buf: ByteWReader): [number /* int */, Error | null] {\n        while(true) /* for */ {\n            console.log(\"Read\", this.toRead)\n            if(this.toRead.length > 0) {\n                // Copy bytes from the output buffer to buf.\n                let n = buf.Copy(this.toRead) // n := copy(b, r.toRead)\n                this.toRead = this.toRead.slice(n) // r.toRead = r.toRead[n:]\n                return [n, null]\n            }\n\n            if(this.err) {\n                return [0, this.err]\n            }\n\n            this.decode()\n        }\n    }\n\n    // decode decompresses bytes from r and leaves them in d.toRead.\n    // read specifies how to decode bytes into codes.\n    // litWidth is the width in bits of literal codes.\n    private decode() {\n        console.log(\"Decode\")\n\n        // Loop over the code stream, converting codes into decompressed bytes.\n        loop: while(true) /* for */ {\n            let [code, err] = this.read()\n\n            if(err) {\n                // Check for EOF\n                if(err.message == IOErrors.EOF) {\n                    err = new Error(IOErrors.UnexpectedEOF)\n                }\n                this.err = err\n                break\n            }\n\n            /* switch { */\n            if(code < this.clear) {\n                // We have a literal code\n                this.output[this.o] = code\n                this.o++\n\n                if(this.last != decoderInvalidCode) {\n                    // Save what the hi code expands to.\n                    this.suffix[this.hi] = code\n                    this.prefix[this.hi] = this.last    \n                }\n            } else if(code == this.clear) {\n                this.width = 1 + this.litWidth\n                this.hi = this.eof\n                this.overflow = (1 << this.width)\n                this.last = decoderInvalidCode\n                continue    \n            } else if(code == this.eof) {\n                this.err = new Error(IOErrors.EOF)\n                break loop\n            } else if(code <= this.hi) {\n                let [c, i] = [code, this.output.length - 1] // c, i := code, len(r.output)-1\n                if(code == this.hi && this.last != decoderInvalidCode) {\n                    // code == hi is a special case which expands to the last expansion\n                    // followed by the head of the last expansion. To find the head, we walk\n                    // the prefix chain until we find a literal code.\n                    c = this.last\n                    while(c >= this.clear) {\n                        c = this.prefix[c]\n                    }\n                    this.output[i] = c\n                    i--\n                    c = this.last    \n                }\n                // Copy the suffix chain into output and then write that to w.\n                while(c >= this.clear) {\n                    this.output[i] = this.suffix[c]\n                    i--\n                    c = this.prefix[c]\n                }\n                this.output[i] = c\n                // copy(r.output[r.o:], r.output[i:]) in JS\n                let srcArray = this.output.slice(i)\n                for(let i = 0; i < srcArray.length; i++) {\n                    this.output[this.o + i] = srcArray[i]\n                }\n                this.o += srcArray.length\n                // End: copy\n\n                if (this.last != decoderInvalidCode) {\n                    // Save what the hi code expands to.\n                    this.suffix[this.hi] = c\n                    this.prefix[this.hi] = this.last\n                }    \n            } else {\n                this.err = new Error(\"lzw: invalid code\")\n                break loop\n            }\n        \n            // https://cs.opensource.google/go/go/+/refs/tags/go1.21.3:src/compress/lzw/reader.go;l=201\n            this.last = code\n            this.hi++\n\n            if(this.hi >= this.overflow) {\n                if(this.hi > this.overflow) {\n                    throw new Error(\"Unreachable\") // panic(\"unreachable\")\n                }\n\n                if(this.width == maxWidth) {\n                    this.last = decoderInvalidCode\n                    // Undo the d.hi++ a few lines above, so that (1) we maintain\n                    // the invariant that d.hi < d.overflow, and (2) d.hi does not\n                    // eventually overflow a uint16.\n                    this.hi--\n                } else {\n                    this.width++\n                    this.overflow = (1 << this.width)\n                }\n            }\n\n            if(this.o >= flushBuffer) {\n                break\n            }    \n        }\n\n        // Flush pending output\n        this.toRead = this.output.slice(0, this.o)\n        this.o = 0        \n    }\n\n    // Close closes the Reader and returns an error for any future read operation.\n    // It does not close the underlying io.Reader.\n    close(): [Error | null] {\n        this.err = new Error(\"lzw: reader/writer is closed\")\n        return [null]\n    }\n}", "import { Tarball, AsyncUint8Array } from '@obsidize/tar-browserify';\nimport { ByteWReader, IOErrors, LZWReader, Order } from './lzwGo';\n\nexport class IblFile {\n    sections: { [key: string]: Uint8Array }\n\n    constructor() {\n        this.sections = {}\n    }\n\n    private lzwDecompress(compressed: Uint8Array) {\n        let lzwReader = new LZWReader(new ByteWReader(compressed), Order.LSB, 8)\n        let bufs: Uint8Array[] = []\n        \n        while(true) {\n            let tmpBuf = new ByteWReader(Uint8Array.from([]))\n            let [n, err] = lzwReader.Read(tmpBuf)\n\n            console.log(\"Read\", n, \"bytes\")\n\n            bufs.push(tmpBuf.jsGetInnerArray())\n\n            if (err) {\n                if(err.message == IOErrors.EOF) {\n                    let finalBuf = new Uint8Array(bufs.reduce((acc, cur) => acc + cur.length, 0))\n                    let offset = 0\n\n                    for(let buf of bufs) {\n                        finalBuf.set(buf, offset)\n                        offset += buf.length\n                    }\n\n                    return finalBuf\n                }\n                throw err\n            }\n        }\n    }\n\n    async parseInput(blob: Uint8Array) {\n        console.log(\"LZW-Decompress\")\n        let lzwDecompressed = this.lzwDecompress(blob)\n\n        console.log(JSON.stringify(Array.from(lzwDecompressed)))\n\n        let asyncBuffer: AsyncUint8Array = {\n            byteLength: async () => {\n                console.log(\"Get byte length\", lzwDecompressed.length)\n                return lzwDecompressed.length\n            },\n            read: async (offset: number, length: number) => {\n                console.log(`Read ${length} bytes at offset ${offset}`)\n                return lzwDecompressed.subarray(offset, offset + length)\n            }\n        }\n\n        console.log(\"Parse Tarball\")\n        \n        await Tarball.streamAsync(asyncBuffer, async (entry, _entryIndex, buffer) => {\n            console.log(entry)\n        })\n    }\n}\n\n"],
  "mappings": "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",
  "names": ["__awaiter", "thisArg", "_arguments", "P", "generator", "adopt", "value", "resolve", "reject", "fulfilled", "step", "e", "rejected", "result", "__values", "o", "s", "m", "i", "__asyncValues", "o", "m", "i", "__values", "verb", "n", "v", "resolve", "reject", "settle", "d", "Constants", "TarUtility", "isNumber", "value", "isString", "isPopulatedString", "isUint8Array", "sizeofUint8Array", "encodeString", "input", "decodeString", "generateChecksum", "a", "b", "clamp", "min", "max", "advanceSectorOffset", "currentOffset", "maxOffset", "advanceSectorOffsetUnclamped", "Constants", "roundUpSectorOffset", "getSectorOffsetDelta", "parseIntOctal", "parseIntSafe", "decodeTimestamp", "encodeTimestamp", "sanitizeTimestamp", "deserializeAsciiPaddedField", "removeTrailingZeros", "deserializeIntegerOctalTimestamp", "deserializeIntegerOctal", "str", "result", "serializeIntegerOctalToString", "maxLength", "radix", "defaultValue", "parsed", "concatUint8Arrays", "aLength", "bLength", "findInAsyncUint8Array", "target", "offset", "stepSize", "predicate", "__awaiter", "maxLength", "TarUtility", "blockSize", "Constants", "found", "cursor", "result", "TarHeaderLinkIndicatorType", "isTarHeaderLinkIndicatorTypeDirectory", "type", "isTarHeaderLinkIndicatorTypeFile", "TarHeaderFieldType", "serializeIntegerOctalTimestamp", "value", "field", "serializeIntegerOctalWithSuffix", "TarUtility", "serializeIntegerOctal", "suffix", "size", "adjustedLength", "serializedString", "fieldTypeTransformMap", "TarHeaderFieldType", "TarHeaderField", "_TarHeaderField", "config", "input", "offset", "start", "end", "transform", "result", "valueLength", "HeaderFieldDefinitions", "TarHeaderField", "TarHeaderFieldType", "Constants", "fieldsByName", "orderedSet", "checksumSet", "v", "isUstarSector", "input", "offset", "checksumSet", "headerChecksum", "orderedSet", "HeaderFieldDefinitions", "CHECKSUM_SEED_STRING", "CHECKSUM_SEED", "TarUtility", "ALL_FIELDS", "CHECKSUM_FIELDS", "sanitizeHeader", "header", "getDefaultHeaderValues", "Constants", "TarHeaderLinkIndicatorType", "TarHeaderMetadata", "_TarHeaderMetadata", "input", "offset", "result", "field", "value", "bytes", "snapshot", "normalizedHeader", "checksum", "headerBuffer", "concatAttributes", "accumulator", "attrs", "TarUtility", "TarEntryAttributes", "_TarEntryAttributes", "header", "content", "value", "values", "v", "snapshots", "padBuffer", "Constants", "parsedAttrs", "contentSize", "offsetDelta", "paddedContent", "safeHeader", "sanitizeHeader", "headerBuffer", "TarHeaderMetadata", "findNextUstarSectorAsync", "input", "offset", "findInAsyncUint8Array", "value", "HeaderFieldDefinitions", "findNextUstarSectorOffset", "TarUtility", "maxOffset", "nextOffset", "TarEntryMetadata", "_TarEntryMetadata", "header", "content", "TarHeaderMetadata", "contentLength", "ustarSectorOffset", "start", "fileSize", "end", "__awaiter", "sector", "TarEntry", "_TarEntry", "metadata", "TarEntryMetadata", "v", "attrs", "content", "header", "TarHeaderMetadata", "input", "offset", "__awaiter", "value", "Constants", "TarUtility", "isTarHeaderLinkIndicatorTypeDirectory", "isTarHeaderLinkIndicatorTypeFile", "buffer", "length", "contentStartIndex", "contentEndIndex", "fileSize", "normalizedOffset", "bytesRemaining", "normalizedLength", "TarEntryAttributes", "fileName", "isFile", "isDirectory", "TarEntryIteratorBase", "value", "TarUtility", "bufferOffset", "bufferLength", "canAdvanceOffset", "entry", "done", "AsyncTarEntryIterator", "_AsyncTarEntryIterator", "TarEntryIteratorBase", "buffer", "onNext", "_a", "e_1", "_b", "_c", "__awaiter", "iterator", "i", "_d", "iterator_1", "__asyncValues", "iterator_1_1", "e_1_1", "result", "entry", "TarEntry", "data", "TarEntryIterator", "_TarEntryIterator", "TarEntryIteratorBase", "buffer", "iterator", "TarEntry", "data", "TarUtility", "Tarball", "_Tarball", "buffer", "TarEntryIterator", "entries", "TarEntryAttributes", "__awaiter", "AsyncTarEntryIterator", "onNext", "attrs", "e", "TarEntry", "path", "content", "headerOptions", "TarUtility", "TarHeaderLinkIndicatorType", "ByteWReader", "buf", "b", "bytes", "LZWReader", "src", "order", "litWidth", "x", "err", "code", "n", "loop", "c", "srcArray", "i", "IblFile", "compressed", "lzwReader", "LZWReader", "ByteWReader", "bufs", "tmpBuf", "n", "err", "finalBuf", "acc", "cur", "offset", "buf", "blob", "lzwDecompressed", "asyncBuffer", "length", "Tarball", "entry", "_entryIndex", "buffer"]
}
